# JavaRTK
## Описание проекта
Данный проект является учебным в рамках круса ПИШ Программная инженерия.
Разработка ПО (Java для начинающих специалистов).
### Домашняя работа № 1. *Установка IDE*
#### Задание:
Установить IDE IntellJ IDEA.
#### *Решение*:
Для выполнения данного домашнего задания необходимо:
1. скачать дистрибутив IntellJ IDEA Community Edition с официального сайта по [ссылке](https://www.jetbrains.com/idea/download/?section=windows);
2. запустить установочный файл и следовать шагам мастера установки;
3. скачать Java с [официального сайта](https://www.oracle.com/java/technologies/javase/jdk21-archive-downloads.html), выбрав в списке свою ОС и разрядность;
4. следуя шагам мастера установки установить JDK (Java Development Kit);
5. открыть свойства компьютера "Компьютер -> Свойства -> Дополнительные параметры системы ->
   Переменные среды";
6. нажать на кнопку "Создать";
7. ввести JAVA_HOME в поле "Имя переменной";
8. в открывшемся окне проводника выбрать путь к установленной Java в поле "Значение переменной".

В результате выполнения данного домашнего задания была установлена JDK 21 и IDE IntellJ IDEA.
### Домашняя работа № 2. *Установка и настройка Git*
#### Задание:
Создать новый Java проект и добавить его в новый репозиторий.
#### *Решение*:
Для выполнения задания необходимо:
1. перейти на сайт [GitHub](https://github.com/);
2. пройти регистрацию (если нет аккаунта);
3. создать новый репозиторий;
4. установить приложение Git Bash (для ОС Windows);
5. создать новый проект в IDE:
   * открыть IDE IntellJ IDEA;
   * выбрать пункт "Create new project":
   * ввести название проекта.
6. в Git Bash осуществить настройку удаленного репозитория:
   * перейти в папку проекта;
   * инициализировать Git при помощи команды "git init";
   * настроить подключение командами:
      * git config --global user.name "YourName";
      * git config --global user.email "your_email@example.com";
      * git remote add origin <URL_new_repository>;
7. добавить новый проект в удаленный репозиторий:
   * добавить папку ".idea" в файл .gitignore;
   * добавить файлы для отслеживания командой «git add .»;
   * создать коммит с названием "first commit";
   * командой «git branch –M main» переименовать ветку master в main;
   * отправить коммит в удаленный репозиторий командой «git push –u origin main».

В результате выполнения данных действий был создан новый репозиторий и добавлен новый проект.
### Домашняя работа № 3. *Работа с программой: пакеты, иерархия папок для Java Core*
#### Основное задание
Необходимо создать приложение, которое принимает имя пользователя из консоли и выводит сообщение
формата "Hello Имя пользователя!".
#### *Решение*:
Для этого создал класс "HelloUser". В данном классе определил метод main().
В методе определил переменную sc типа Scanner и присвоил ей новый экземпляр объекта Scanner,
в качестве аргумента передал конструкцию System.in.

Далее сделал вывод сообщения в консоль с указанием дальнейших действий для пользователя. Создал
переменную типа String, которая принимает значение введенное пользователем. Последним сделал вывод
сообщение "Hello" + Данные пользователя + "!". Основное задание готово.

#### Дополнительное задание
Игра "Камень-Ножницы-Бумага".
#### *Решение*:
Создал двух игроков: Василия и Петра. Создал новый экземпляр класса random. Переменным выбора присвоил
значение функции rand.nextInt(). В которую передал аргументы начала и конца случайно сгенерированных
значений. Далее определил переменные типа String, в которых хранятся значения полученные из метода
convertMore().

Метод convertMore() принимает сгенерированное значение и при помощи конструкции switch/case возвращает
заданное значение, понятное человеку.

Далее создал условие, при котором возникает ничья. После прописал условие, при которых побеждает Василий.
В противном случае выигрывает Петр. В теле сделал вывод результата в консоль.

### Домашняя работа № 4. *Классы: поля, свойства, методы*
#### Основное задание
Реализовать класс Телевизор. У класса есть поля, свойства и методы. Проверить работу в классе App,
методе main.
#### Дополнительное задание
Задавать параметры класса Телевизор с клавиатуры или случайным числом.
#### *Решение*:
Создал класс "TV" в нем определил следующие свойства:
* бренд;
* модель;
* диагональ;
* текущий канал;
* текущая громкость.

Создал метод конструктора для данного класса. Далее создал методы получения данных
о телевизоре getTVName() и getInfo(). Реализовал методы управления телевизором
такие как:
* включение / выключение - power();
* изменение громкости - changeVolume();
* переключение каналов - changeChannel().

Разработал метод checkChannelList(), который хранит в хэш-массиве список доступных
каналов.

Далее приступил к разработке класса "App". В нем создал метод main(). В данном
методе определил два экземпляра класса "TV". Вывел сообщения пользователю о том,
какой телевизор используется и какие команды доступны для управления устройством.
Далее вызвал рекурсивный метод availableFunctions().

Метод availableFunctions() в качестве аргумента устройство, с которым идет
взаимодействие. Данный метод принимает команду из консоли, введенную пользователем
в метод remoteControlFunctions() и выводит соответствующий результат.

Метод remoteControlFunctions() содержит в себе конструкцию switch/case которая
вызывает методы класса TV.

### Домашняя работа № 5. *Класс Object. Класс String*
#### Задача 1.
Для введенной с клавиатуры буквы английского алфавита нужно вывести слева стоящую
букву на стандартной клавиатуре. При этом клавиатура замкнута, т.е. справа от буквы
«p» стоит буква «a», а слева от "а" буква "р", также соседними считаются буквы «l» и
буква «z», а буква «m» с буквой «q».

**Входные данные**: строка входного потока содержит один символ — маленькую букву
английского алфавита.

**Выходные данные**: следует вывести букву стоящую слева от заданной
буквы, с учетом замкнутости клавиатуры.
#### *Решение*:
Создал класс "KeyboardCircle", в котором сделал метод main(). В данном методе
реализовал вывод для пользователя и создал новый экземпляр типа Scanner,
который принимает введенное пользователем значение. Далее вызывал метод
changeSymbol() в который передал первый символ введенной пользователем строки.

В методе changeSymbol() создал хэш-таблицу, которая возвращает заданное значение.

#### Задача 2.
Задана последовательность, состоящая только из символов ‘>’,
‘<’ и ‘-‘. Требуется найти количество стрел, которые спрятаны в этой
последовательности. Стрелы – это подстроки вида ‘>>-->’ и ‘<--<<’.
Входные данные: в первой строке входного потока записана строка,
состоящая из символов ‘>’, ‘<’ и ‘-‘ (без пробелов). Строка может содержать до
106 символов.

**Выходные данные**: в единственную строку выходного потока нужно вывести искомое
количество стрелок.
#### *Решение*:
Создал класс "SearchForArrows", в котором сделал метод main(). В данном методе
реализовал вывод для пользователя и создал новый экземпляр типа Scanner,
который принимает введенное пользователем значение. Далее разбил полученную на
массив символов и создал переменную типа int для счетчика найденных стрел и
объявил новый экземпляр класса StringBuilder для соединения пяти символов в строку.

При помощи цикла перебрал массив. В цикле установил условие, которое ограничивает
проход до последних четырех символов, так как из них не получатся заданные
виды стрел. Далее осуществил объединение интервала символов от текущего + 5
символов вперед конвертировал полученные символы в строку и сверил с заданными
значениями. При выполнении условий увеличил счетчик на единицу.

По окончанию цикла выполнил вывод значения счетчика пользователю.

#### Задача 3. *Дополнительная*
Задана строка, состоящая из букв английского алфавита,
разделенных одним пробелом. Необходимо каждую последовательность
символов упорядочить по возрастанию и вывести слова в нижнем регистре.
Входные данные: в единственной строке последовательность символов
представляющее два слова.

**Выходные данные**: упорядоченные по возрастанию буквы в нижнем
регистре.
#### *Решение*:
Создал класс "SelectionSort", в котором сделал метод main(). В данном методе
реализовал вывод для пользователя и создал новый экземпляр типа Scanner,
который принимает введенное пользователем значение. Далее понизил регистр
функцией toLowerCase() и разделил полученную строку в массив строк при помощи
функции split указав разделителем знак пробела.

Циклом перебрал значения массива и каждое значение отправил в метод
selectionSort().

После цикла сделал вывод полученной строки соединив элементы массива функцией
join(), передав в качестве соединителя – пробел и полученный массив.

Метод selectionSort() принимает строку. В теле метода первым делом разбил строку
на массив символов. Далее объявил пустой массив, задав конечное количество
элементов. Объявил переменную, отвечающую за позицию сортировки.

Далее реализовал цикл while в котором первый цикл for ищет наименьший символ и его
индекс. Далее полученный результат отравил в отсортированный результат.
Второй цикл удаляет элемент из unsorted и создаёт новый массив, уже без найденного
символа. После сортировки собрал массив в строку и отправил в метод main()

### Аттестация.
#### Задание:
Необходимо реализовать приложение, принимающее список  пользователей, продуктов и
обрабатывающее покупку пользователя.
#### *Решение*:

**Этап 1. Создание класса Person**

Создал класс "Person" в котором создал переменные:
* fullName – имя покупателя;
* cash – баланс;
* productPackage – купленные товары.

Далее реализовал конструктор класса, в который добавил методы setFullName() и
setCash().

Разработал методы get и set для переменных fullName и cash.

В методах set предусмотрел вывод предупреждения с завершением работы программы при
некорректно введенных данных.

Создал метод buy(), который проверяет достаточно ли у человека денег и при успехе
вычитает из баланса стоимость продукта, добавляет товар в массив со списком
купленных товаров и выводит сообщение об успешной покупке. В противном случае
метод выводит сообщение о невозможности приобрести данный товар.

Реализовал метод getProducts() который проверяет список купленных товаров на
пустоту и в случае, когда список не пуст выводит имя клиента и список купленных
товаров через запятую. В противном случае выводит сообщение с именем клиента и
что ничего не куплено.

**Этап 2. Создание класса Product**

Создал класс "Product", в котором объявил переменные name и price. Реализовал
конструктор класса и методы получения данных, так как прямого доступа к переменным
нет, так как они приватные.

**Этап 3. Создание класса App**

Создал класс App, в котором создал метод main(). Данный метод выводит пользователю
сообщения, о том какие данные и в каком формате необходимо ввести. Далее введенные
пользователем данные отправляются в метод parse(). После создания массивов с
клиентами и продуктами вызывается метод makeAPurchase().

В методе parse() создаются массивы клиентов и продуктов. На входе данный метод
получает: строку, введенную пользователем, и название класса, чьи данные будут
записываться в массив. Далее полученная строка разбивается на массив строк при
помощи функции split() и полученные пары значений перебираются при помощи цикла.
В цикле полученную пару значений разбил на конечные значения и добавил новый
экземпляр класса в массив при помощи метода apply(), в который передал конечные
значения удалив из них лишние пробелы.

Метод makeAPurchase() отвечает за реализацию покупок пользователями. Данный метод
принимает два массива: Массив клиентов и массив продуктов. Сначала сделал вывод
сообщения пользователю, какие данные и в каком формате необходимо ввести. Далее
проверяем введенную команду, что она является “END”. При успешном прохождении
данного условия выполняю цикл по всем пользователям и вызываю метод getProducts()
который выводит в консоль список покупок клиента. В противном случае выполняется
разбиение по символу «-» далее создал переменные, которые содержат окончательные
данные без лишних пробелов. Далее выполняю поиск по массиву и получаю необходимые
экземпляры классов Person и Product. Далее вызвал метод buy() у класса Person и
передал экземпляр класса Product. В конце вызвал метод makeAPurchase(), тем самым
создал рекурсию для ввода данных покупок до ввода команды “END”.

**Этап 4. Добавление новой ветки в Git**

Для выполнения данной части задания:
1. создал новую ветку и сразу перешел в неё командой:
   git checkout-b attestation/attestation01
2. добавил изменения командой - git add .
3. проверил добавленные файлы командой - git status
4. добавил новый коммит- git commit -m “Attestation”
5. оправил изменения в удаленный репозиторий при помощи
   команды - git push origin –u attestation/attestation01

### Домашняя работа № 6. *Понятия ООП: наследование, полиморфизм*
#### Задание:
Расширить программу из задания с промежуточной аттестации.
Добавить механизм наследования.
#### *Решение*:

**Этап 1. Создание класса DiscountProduct и доработка класса Product**

Выполнение решил начать с создания нового класса "DiscountProduct". При объявлении
класса указал, что данный класс наследуется от класса Product при помощи ключевого
слова *extends*. Задал свойства:
* процент скидки (тип int);
* дата окончания скидки (тип LocalDate);
* окончательная цена (double).

Разработал конструктор класса, в который передал аргументы родительского класса, такие
как название, цена и добавил новые свойства. В конструкторе вызвал родительский
конструктор при помощи метода super(), в который передал значения, необходимые
родительскому классу.

В методе setPercentDiscount() реализовал условия, при которых скидка будет
некорректна. Определил getter-ы для всех новых свойств, за исключение окончательной цены.
Далее определил метод isDiscountActive(), который проверяет срок действия скидки и возвращает true
или false. Добавил метод getEffectivePrice(), в которой подводится расчет новой цены, при условии, что
скидка действительна. Переопределил метод getPrice().

В классе "Product" изменил тип свойства "цена" с int на double, переопределил методы toString(),
HashCode() и equals(). После этого в классе DiscountProduct переопределил метод toString(), в котором
к функциональности родительского класса добавил новые свойства.

**Этап 2. Доработка класса App**

Начал с оптимизации кода. Переработал метод main(). Вынес в отдельные функции создание новых
экземпляров классов createPerson() и createProduct(), в качестве входных параметров получающие
список объектов и строку, введенную пользователем в консоли. Данные методы ничего не возвращают, а
просто добавляют созданные экземпляры классов в список. Ввел метод getConsoleData(), который принимает
в качестве аргументов ранее созданный метод интерфейса ConsoleParser и список. В данном методе
реализован новый экземпляр Scanner и условие, при котором данный метод является рекурсивным.
В условии определил метод интерфейса, который вызывает переданную в getConsoleData() функцию класса App.

Для добавления разных экземпляров в список products разработал интерфейс Item, в котором определил
метод getInfo(). Далее вернулся в класс "Product", при помощи ключевого слова *implements* указал, что
данный класс реализует методы данного интерфейса и создал метод getInfo(), который возвращает название
продукта. В классе DiscountProduct переопределять данный метод не стал.

Доработал метод makeAPurchase(), добавив в него вызов метода getObjectFromList(). Данный метод получает:
* список, в котором ведется поиск;
* название функции, которая возвращает искомое значение из класса;
* переменную, по которой выполняется поиск объекта в списке.

Данный метод возвращает найденный объект, в противном случае выбрасывается исключение.

Дополнил метод проверкой типа полученного объекта и при получении необходимого выполняется метод buy()
класса "Person".

**Этап 3. Создание новой ветки для данной задачи на GitHub**

### Домашняя работа № 8. *Generics, Коллекции*
#### Задание 1:
Реализовать метод, который на вход принимает ArrayList<T>, а возвращает набор
уникальных элементов этого массива. Решить, используя коллекции
#### *Решение*:

Создал метод uniqueElements(), который принимает ArrayList<T> и возвращает Set<T>. В данном методе при
помощи Stream API метода .distinct и вывел результат при помощи теримнального метода .toList. Полученные
значения записал в новый HashSet и вернул данное значение.
В методе main() создал новый ArrayList, заполнил его значениями (с повторами). Объявил переменную,
которая будет хранить результат выполнения метода uniqueElements(). Выполнил вывод в консоль значение
ранее созданной переменной.

#### Задание 2:
С консоли на вход подается две строки s и t. Необходимо вывести true, если одна строка является валидной
анаграммой другой строки, и false – если это не так.
#### *Решение*:

Создал новый класс, в нем реализовал метод main(). В данном методе сделал вывод сообщений пользователю в
консоль и получение двух строк, введенных пользователем, из консоли. Последней строчкой сделал вывод
результат работы метода anagramCheck().

Метод anagramCheck() принимает в качестве аргуметнов две строки, в качестве результата возвращает
логическое значение. В данном методе сначала проверяю длинны полученных строк. Если они не равны, то
метод возвращает значение "false". Иначе продолжается работа над строками. Передал в функцию valueOf
класса String строку, которой понизил регистр и разбил ее на символы. Далее отсортировал символы методом
.sorted() и полученные массивы собрал в строку, используя теримнальный метод .collect(), в котором при
помощи StringBuilder собрал обратно строку. То же самое проделал и со второй строкой. Последней строчкой
возвращаю результат сравнения полученных строк.

#### Задание 3:
Реализовать класс PowerfulSet, в котором должны быть следующие методы:
● public <T> Set<T> intersection(Set<T> set1, Set<T> set2) – возвращает
пересечение двух наборов.
Пример: set1 = {1, 2, 3}, set2 = {0, 1, 2, 4}. Вернуть {1, 2}
● public <T> Set<T> union(Set<T> set1, Set<T> set2) – возвращает
объединение двух наборов
Пример: set1 = {1, 2, 3}, set2 = {0, 1, 2, 4}. Вернуть {0, 1, 2, 3, 4}
● public <T> Set<T> relativeComplement(Set<T> set1, Set<T> set2) –
возвращает элементы первого набора без тех, которые находятся также и
во втором наборе.
Пример: set1 = {1, 2, 3}, set2 = {0, 1, 2, 4}. Вернуть {3}
#### *Решение*:

Создал новый файл класса PowerfulSet. В нем создал три метода intersection(), union() и relativeComplement().
В методе intersection() при помощи Stream API перебрал значения переменной set1 и проверил наличие значения
в set2 в методе .filter(). Далее при помощи терминального метода .collect() добавил отфильтрованные значения
в новый Set.

Далее реализовал метод union(). В нем создал новый HashSet, который заполнил значениями переменной set1
и добавил в него значения set2. Данный способ сработает и не будет дублирующих значений, так как Set
содержит только уникальные значения.

Последним реализовал метод relativeComplement() он схож по реализации с методом intersection(), только в
условии добавил отрицание.

Далее приступил к реализации исполняемого класса. В нем реализовал метод main() в котором создал два Set,
создал экземпляр класса PowerfulSet и выполнил вывод результатов значений.

### Домашняя работа № 9. *Java Collections. Stream API*
#### Задание:

1. Реализовать класс Автомобиль. У класса есть поля, свойства и методы. Поля класса:\
а) Номер автомобиля;\
б) Модель;\
в) Цвет;\
г) Пробег;\
д) Стоимость.\
Обратить внимание на переопределение метода toString, на сеттеры и геттеры, модификаторы доступа полей.
2. Проверить работу в классе Main, методе main.
3. Создать объект Java Collections со списком автомобилей.
4. Используя Java Stream API, вывести (можно сделать любые 2 пункта из 4):
    - Номера всех автомобилей, имеющих заданный в переменной цвет colorToFind или нулевой пробег mileageToFind.
    - Количество уникальных моделей в ценовом диапазоне от n до m тыс.
    - Вывести цвет автомобиля с минимальной стоимостью.
    - Среднюю стоимость искомой модели modelToFind.

#### *Решение*:
Создал файловую структуру указанную в задании:\
Homework9
   - data
     - cars.txt
   - model
     - Car.java
   - repository
     - CarRepository.java
     - CarRepositoryImpl.java
     - FileLogger.java
     - Logger.java
     - TxtLogger
   - test
     - Main.java

Далее приступил к созданию класса Car. Определил свойства, конструктор класса, геттеры и переопределил метод toString()\
В папке repository реализовал интерфейс CarRepository в котором определил методы необходимые для решения задачи и выполнил их реализации в
CarRepositoryImpl.
В методе colorToFind() определил аргументы лист со списком автомобилей и цвет, по которому осуществляется поиск.
В самом методе при помощи Stream API отфильтровал элементы по цвету и пробегу и вернул список номеров автомобилей подходящих под условия.\
В метод uniqueAuto() передал список автомобилей и два числа, которые образуют диапазон для сортировки элементов. 
Далее подсчитал количество полученных элементов при помощи метода .count() и вернул полученное число.\
Реализовал метод lowerCoast() в который передал только список автомобилей и при помощи конструкции .min(Comparator.comparing(Car::getPrice)) получил 
автомобиль с минимальной стоймостью и вернул его цвет.
В метод modelToFind() передал список автомобилей и модель по которому необходимо найти автомобиле в списке. При помощи конструкции
.mapToInt(Car::getPrice).average() получил среднее значение стоимости автомобилей запрошенной марки.

Далее реализовал метод Main, в котором создал ArrayList со списком автомобилей. Далее создал экземпляр класса CarRepositoryImpl и далее реализовал 
вывод в консоль результаты работы методов. 

После реализовал интерфейс Logger и класс FileLogger, который исполняет интерфейс Logger. Для записи данных в файл реализовал класс TxtLogger который записывает данные 
в txt файл. В классе Main создал новый экземпляр класса txtLogger типа Logger и передал значения, которые необходимо записать в файл. 
При создании нового экземпляра класса типа Logger указал полный путь до файла cars.txt.

P.S. Задержал выполнение данного задания из-за того что был в отпуске и не было возможности работать за компьютером.

